<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@100&display=swap" rel="stylesheet">
    <link href="https://fonts.cdnfonts.com/css/basier" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Antonio:wght@100&family=DM+Mono:wght@300&family=Bungee+Hairline&family=Sono:wght@300&family=Telex&family=Commissioner:wght@300&family=Creepster&family=Nabla&family=Foldit&family=Codystar&family=Libre+Barcode+39+Extended+Text&family=Bungee+Hairline&family=Fontdiner+Swanky&family=Mrs+Saint+Delafield&family=UnifrakturMaguntia&family=Sigmar+One&family=Reenie+Beanie&family=Lora&family=Ewert&family=Dr+Sugiyama&family=Gruppo&family=Marhey&family=Mountains+of+Christmas&family=Moirai+One&family=Moo+Lah+Lah&family=Mynerve&family=Rubik+Glitch&family=Rubik+Burned&family=Rubik+Lines&family=Satisfy&family=Barrio&family=Silkscreen&family=Special+Elite&family=Zeyada&display=swap" rel="stylesheet">        
    <!-- <link rel="stylesheet" media="screen and (max-width: 600px)" href="style_mobile.css"> -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/remixicon@4.1.0/fonts/remixicon.css">
    <link rel="icon" href="https://static.vecteezy.com/system/resources/previews/009/266/750/non_2x/sun-icon-design-free-png.png" type="image/png">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/projects.css">
    <script src="https://kit.fontawesome.com/7ed75dc688.js" crossorigin="anonymous"></script>
    <script src="https://worldtimeapi.org/api/timezone/America/Los_Angeles"></script>
    <script src = "/js/right-banner.js"></script>
    <title>alisons⭒computer</title> 
</head>
<style>
    #description-body{
        font-family: "Commissioner", sans-serif;
        font-optical-sizing: auto;
        font-weight: 300;
        font-style: normal;
        font-size: 0.8em;
        width: 90%;
        margin: 0 auto;
        margin-top: 1em;
    }

    .media-caption{
        font-family: "Sono", monospace;
        font-size: 0.8em;
        margin: 1em auto;
        width: fit-content;
    }
    div p{
        margin-bottom: 1em;
    }

    .project-section{
        font-size: 1em;
        margin: 1em 0em;
    }

    .project-subsection{
        font-size: 1em;
        margin: 1em 0em;

    }
</style>
<body>
    <section>
        <nav id = "nav-bar" class="banner">
            <div class="left-header">
                <a style = "text-decoration: none;" href = "/" class = "title">
                    <span>alisons.</span>
                    <span id = "computer">computer</span>
                </a>
            </div>
            <div id = "sub-title"></div>
            <div class = "right-header">
                <span id = "line-1">It is <span id = "local-time"></span><i id = "day-or-night" class="fa-solid fa-cloud-sun"></i></span>
                <span id = "line-2"><i class="ri-calendar-event-fill"></i> <span id = "day-of-week"></span><span id = "full-date"></span></span>
                <span id = "line-3"><span id = "temperature"></span> & <span id = "weather"></span><img id = 'weather-icon' class = "icon-here"></img></span>
            </div>
        </nav>
    </section>
    <section id = "section-project-page">
        <div class="page-buttons">
            <span id = "link-home"><a href = "/"><i class="ri-arrow-left-up-line"></i> back to main page</a></span>
            <span id = "link-next-project"><a href = "../requiem/index.html">Requiem for a Friend <i class="ri-arrow-right-up-line"></i></a></span>
        </div>
        <div class="project-header">
            <div id="project-title">play (with) music</div>
            <div class = "project-details">
                <span id="project-year">2024</span><span id="project-tools">Spotify API, d3.js, NLTK, scikit-learn, jQuery</span>
                <div id="project-link">
                    <a href = "https://github.com/alisonkim12/play-with-music" target="_blank">github repo <i class="ri-link"></i></a>
                </div>
            </div>
        </div>
        <div id="description-body">
            <div>
                <p style = "font-style: italic; font-size: 1em; color: rgba(0,0,0,0.6);">Play (with) music represents a unique exploration into the intersection of music data analysis and interactive visualization. Designed to enhance user engagement with Spotify playlists, it utilizes robust technologies like D3.js and NLTK to create a dynamic interface where each song is visually represented by animated circles. The project incorporates six distinct visualization filters derived from Spotify API data, including criteria such as decade, genre, lyric similarity, popularity, energy, and danceability. Lyrics for each song are sourced through the LyricsGenius API, undergo comprehensive preprocessing, clustering, and subsequent visualization using advanced techniques like TF-IDF vectorization, K-Means clustering, and Principal Component Analysis. Technical implementation includes ensuring security and authentication protocols such as SSL/TLS compatibility, OAuth2 authorization flow management, and robust handling of network issues through Python's requests.Session object. Supported by a diverse toolkit including Spotify API, scikit-learn, matplotlib, jQuery, Flask, and Python, this project aims to provide a comprehensive framework for exploring and interpreting music data with precision and depth.
                </p>
            </div>
            <div style = "width: 100%; padding-bottom: 0.5em; border-bottom: 0.5px solid black;">Project backend</div>
            <div class = "project-section" style = "font-style: italic;">Part 1: Spotify API Info (main.py) 
            </div>
            <div style = "width: 60%; margin-left: 2%; margin-bottom: 1%; float: right;">
                <video style = "width: 100%;" muted playsinline>
                    <source src="/media/Spotify/mainPage.webm" type="video/webm">
                    <source src="/media/Spotify/mainPage.mp4" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
                <div class = "media-caption">[ main page ]</div>
            </div>
            <p>The main backend script (main.py) utilizing the Spotify API and Flask, allows querying Spotify playlists and processing track information. The script starts by importing necessary libraries: ‘requests’ and ‘urllib.parse’ for handling HTTP requests and URL parsing, urllib.error for HTTP error handling, `requests.adapters.HTTPAdapter and urllib3.util.retry.Retry for configuring request retries, ‘time’ for delays, ‘json’ for JSON operations, ‘ssl’ for SSL configurations, `datetime` for date and time operations, and Flask components for web server functionality. 
            </p>
            <p>A function ‘sslwrap(func)’ is defined using the `wraps` decorator from `functools`, ensuring SSL/TLS protocol version compatibility by wrapping the SSL socket. The Flask application is initialized with a secret key for session management. Essential Spotify API credentials and endpoints are defined, and a `requests.Session` object ‘my_session’ is configured with retry capabilities for handling transient network issues.
            </p>
            <p>The Flask route (/) serves the index page, rendering ‘index.html’. The ‘/login’ route initiates the OAuth2 authorization process with Spotify, redirecting users to Spotify's authorization page with necessary parameters. The ‘/callback’ route handles the OAuth2 callback, exchanging the authorization code for an access token and storing token information in the session. The ‘/refresh-token’ route handles token refresh logic, sending a POST request to the Spotify API to obtain a new access token using the refresh token and updating the session with the new token information.
            </p>
            <p>The ‘/playlists’ route fetches the user's playlists using the stored access token, checking for token expiration and refreshing if necessary. It sends a GET request to the Spotify API to retrieve playlists,  manages potential request exceptions, and iterates through each playlist to fetch track information by calling a helper function that retrieves detailed information about each track, including song name, artist name, album name, album cover image, and year of release. A separate API request is made for each Spotify song that gathers audio features like song genre, popularity index, danceability index, and energy index. All aforementioned data associated with each song are stored within one massive dictionary, with five smaller dictionaries representing each playlist’s data. The script writes this data to a JSON file, ‘tracks.json’, and triggers lyric processing for each track by calling ‘preprocessing_lyrics’ and ‘analyzing_song_lyrics’ functions from python scripts, ‘lyrics.py’ and ‘lyricsanalysis.py’ respectively, that handle lyric processing and analysis for each playlist (more info in part 2).  This setup ensures secure handling of user authentication, retrieval of playlist and track data from Spotify, and processing of the data for further analysis.
            </p>
            <p>This setup ensures secure handling of user authentication, retrieval of playlist and track data from Spotify, and processing of the data for further analysis.
            </p>
            <div class = "project-section" style = "font-style: italic;">Part 2: Lyric Analysis (lyrics.py + lyricanalysis.py)</div>
            <p>The lyric processing module analyzes and visualizes lyrics from songs in a user's Spotify playlist, employing a range of Natural Language Processing (NLP) and Machine Learning (ML) techniques. The primary goal was to plot each lyric line on a 2D plane, revealing patterns and clusters within the text data.</p>
            <div class = "project-subsection" style = "font-style: italic;">lyrics.py:</div>
            <p>First, each song from every playlist was preprocessed by obtaining song lyrics from the Genius API. Several libraries were imported: ‘lyricsgenius’ for interacting with the Genius API, ‘re’ for regular expression operations, ‘json’ for reading JSON files, ‘csv’ for writing to CSV files, ‘os’ for operating system interactions, and ‘time’ for introducing delays. The main function starts by reading .json files listing every track name, one for each playlist generated from main.py from the `./static/` directory, and loading its contents into a constant variable. The Genius API client is then initialized with an access token and a timeout of 40 seconds, and an attempt is made to fetch lyrics for a given song title from the API, introducing a 2-second delay between requests to avoid rate limiting. If lyrics are found and their length is less than 2000 characters, they are returned; otherwise, `None` is returned. The function also includes error handling to catch and print exceptions during the API request. Each song's lyrics are cleaned by removing unnecessary text, common filler words, and phrases such as "[Chorus]" and "[Verse]", using regular expressions to remove non-alphabetic characters, extra whitespace, digits, and Unicode characters. The final cleaned lyrics are constructed by concatenating non-empty processed lines. A relative path for output CSV files associated with each playlist is constructed and filled with the preprocessed lyrics.
            </p>
            <div class = "project-subsection"style = "font-style: italic;">lyricanalysis.py:</div>
            <p>To analyze and visualize each lyric from the songs for each playlist, a combination of NLP tools for text preprocessing and ML algorithms for clustering and topic modeling was used. Song lyrics were sourced from the Lyric Genius API and split into individual lines. The dataset, consisting of individual lyric lines along with song titles and artists, was then cleaned and preprocessed—tokenized into words, converted to lowercase, filtered to remove stopwords and non-alphanumeric tokens, and lemmatized to obtain their base forms. Text processing involved the use of several NLTK package modules including WordNet, stopwords, and the Punkt tokenizer.
            </p>
            <div style = "float: left; width: 30%; top: -8px; left: -1%; position: relative;">
                <img alt = "diagram outlining the different components of the project stack" width = 100% src = "/media/Spotify/spotify stack flow.png">
                <div style = "margin-top: 0.5em !important;" class = "media-caption">[ project stack flow ]</div>
            </div>
            <p>The text was transformed into Term Frequency-Inverse Document Frequency (TF-IDF) feature vectors using the TfidfVectorizer module from the Scikit-learn library, which numerically represented the importance of each word in the context of the entire corpus. With these feature vectors, K-Means clustering was applied to group the lyric lines into 15 distinct clusters based on their textual similarities. The clustering process involved fitting the K-Means algorithm to the TF-IDF vectors and assigning each lyric line to one of the clusters. Furthermore, Latent Dirichlet Allocation (LDA) was employed for topic modeling, extracting the three top words that characterize each topic. These top words were then used to create identifiers for each cluster. To calculate the precision of the clustering results, cosine similarity scores were computed between each lyric line and the centroid of its assigned cluster, providing a measure of how closely each line matched the central theme of its cluster. Additionally, confidence levels were calculated based on the Euclidean distance to the nearest cluster center, with higher confidence corresponding to shorter distances.
            </p>
            <p>To visualize the analysis, dimensionality reduction on the TF-IDF vectors was performed using Principal Component Analysis (PCA), reducing the high-dimensional data to two principal components. This was used to plot the lyric lines in a 2D space, where each point represents a lyric line and is color-coded based on its cluster assignment. The processed data, the computed 2D coordinates, cluster assignments, cosine similarity scores, and confidence levels, along with the corresponding lyric line, song title, and artist, were saved to a localized CSV file.
            </p>
            <p>By meticulously preprocessing the lyrics, transforming the data into meaningful numerical representations, and applying clustering and topic modeling techniques, it allows users to identify distinct themes and topics across different songs. The visualization of these themes through dimensionality reduction and 2D plotting not only highlights the diversity and commonalities within the playlists but also provides an intuitive way to explore the lyrical content. 
            </p>
            <div style = "width: 100%; padding-bottom: 0.5em; border-bottom: 0.5px solid black;">Project frontend</div>
            <div class = "project-section" style = "font-style: italic;">Landing Page (landingpage.html)</div>
            <div>
                <div style = "width: 30%; margin-left: 2%; margin-bottom: 1%; height: fit-content; min-width: 350px; float: right;">
                    <video style = "width: 100%;" muted playsinline>
                        <source src="/media/Spotify/landingpage.webm" type="video/webm">
                        <source src="/media/Spotify/landingpage.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                    <div class = "media-caption">[ Landing Page ]</div>
                </div>
                <p>The application begins on the landing page, with a backdrop animated song nodes with a button that redirects them to login to their Spotify account and grant permission to access their playlists and account data.
                </p>
            </div> 
            <div class = "project-section" style = "font-style: italic;">Main Page</div>
            <div class = "project-subsection" style = "font-style: italic;">A) User Tool Container (playlist.html)</div>
            <div style = "width: 35%; margin-right: 2em; float: left;">
                <video style = "width: 100%;" muted playsinline>
                    <source src="/media/Spotify/userInterface.webm" type="video/webm">
                    <source src="/media/Spotify/userInterface.mp4" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
                <div style = 'margin-bottom: 1em;' class = "media-caption">[ user interface ]</div>
           </div>
            <p>The main page is divided into three main components. First is a user interactive interface where users can control the mechanisms of the project/web page: five dials representing each playlist, and two meters exhibiting the different data visualization options. There is also a record player displaying the album cover on the vinyl record with song title, album, and artist information displayed at the bottom that changes upon hovering through the song nodes. 
            </p>
            <p>The second and third components are two SVG elements representing the songs on each playlist through circular nodes created via D3.js with each circle displaying the song’s album cover. The main svg is displayed on the right half of the page, animating song data on a two dimensional scale. For example, song genres are displayed on a grid-like form (see video). Popularity, energy, and danceability values are represented by the size of the circles—the higher the value, the larger the node. The decade attribute is visualized by configuring the nodes vertically by decade. Lastly, a ‘recombine’ button in the user interface repositions all the nodes to the center of the SVG. 
            </p>
            <p>The second and third components are two SVG elements representing the songs on each playlist through circular nodes created via D3.js with each circle displaying the song’s album cover. The main svg is displayed on the right half of the page, animating song data on a two dimensional scale. For example, song genres are displayed on a grid-like form (see video). Popularity, energy, and danceability values are represented by the size of the circles—the higher the value, the larger the node. The decade attribute is visualized by configuring the nodes vertically by decade. Lastly, a ‘recombine’ button in the user interface repositions all the nodes to the center of the SVG. 
            </p>
            <p>A smaller SVG is placed directly underneath the interface frame. The SVG visualizes the numerical index of popularity, energy, danceability, and decade by positioning the song nodes with respect to their data values on a one dimensional, horizontal axis. The default attribute visualized on the node for both SVGs upon loading the page is popularity. Thus, when switching around to different playlists, the SVGs are reset to their default configuration. 
            </p>
            <div class = "project-section" style = "font-style: italic;">B) Main svg.+ Little svg (bubble_chart.js + Little_chart.js)</div>
            <div class = "project-subsection" style = "font-style: italic;">Main svg (bubble_chart.js)</div>
            <div style = "width: 30%; height: fit-content; margin-left: 2%; margin-bottom: 1%; float: right;">
                <video style = "width: 100%;" muted playsinline>
                    <source src="/media/Spotify/mainSVG.webm" type="video/webm">
                    <source src="/media/Spotify/mainSVG.mp4" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
                <div class = "media-caption">[ main SVG ]</div>
            </div>
            <p>The functionality of the main svg is driven by the ‘create_bubbles()’ function defined in the ‘bubble_chart.js’ script. This function is called in the ‘main.js’ script that passes the data of the songs from the current active playlist as the parameter. In essence, the function dynamically generates a bubble chart visualization where each circle node represents a song, utilizing D3.js for data binding, scales, forces, and interactivity to provide an engaging exploration of the designated playlist’s song dataset.
            </p>
            <p>Firstly, it selects the main SVG element and clears any existing content within the SVG to reset for each playlist. Then, circle elements representing songs are appended to the SVG, each with its own radius and fill pattern based on the track popularity and image. Drag behavior is implemented for interactivity, allowing circles to be dragged smoothly. A force simulation is set up with various forces like charge, centering, and collision detection. Tooltip functionality is added for mouseover events on circles to display song details that are displayed on the user interface. 
            </p>
            <p>Interactive buttons for genre, decade, combine, energy, popularity, and danceability from the main page are defined for user interaction, triggering changes in circle positions and sizes based on selected criteria. To position circles by genre and decade, the function sets up scales and forces that are triggered upon clicking the genre and decade button, respectively. It creates new object literals to store distinct genres and decades present in the parameter dataset. The built-in javascript map() function is utilized to create new arrays for each song by taking the dimensions of the SVG and generating numeral positionings in the SVG based on its genre and decade. Upon clicking the buttons, D3 forces simulations evenly distributes the circle nodes based on the data and appropriately scale them based on the size of the SVG. Genre configuration creates an uniform grid layout based on the number of distinct genres represented in the dataset. Decade configuration distributes the nodes vertically, clustering them by the decade the song was released. 
            </p>
            <p>Interactive buttons for genre, decade, combine, energy, popularity, and danceability from the main page are defined for user interaction, triggering changes in circle positions and sizes based on selected criteria. To position circles by genre and decade, the function sets up scales and forces that are triggered upon clicking the genre and decade button, respectively. It creates new object literals to store distinct genres and decades present in the parameter dataset. The built-in javascript map() function is utilized to create new arrays for each song by taking the dimensions of the SVG and generating numeral positionings in the SVG based on its genre and decade. Upon clicking the buttons, D3 forces simulations evenly distributes the circle nodes based on the data and appropriately scale them based on the size of the SVG. Genre configuration creates an uniform grid layout based on the number of distinct genres represented in the dataset. Decade configuration distributes the nodes vertically, clustering them by the decade the song was released. 
            </p>
            <p>For energy, popularity, and danceability animations, the song circle’s radius changes with respect to the value associated with each song. Helper functions are defined to calculate the minimum and maximum radius range based on the width of the SVG and number of tracks. It sets up radiusScale() and trackdetailsScale() scales using d3.scaleSqrt() to map data values to circle radii. The ‘combine’ button utilizes both X and Y forces to bring the circles to the center of the SVG. The forceCollide D3 method  is implemented to ensure that circles do not overlap.
            </p>
            <div class = "project-subsection" style = "font-style: italic;">Little svg (little_chart.js)</div>
            <div style = "width: 40%; margin-left: 2%; margin-bottom: 1%; float: right;">
                <video style = "width: 100%;" muted playsinline>
                    <source src="/media/Spotify/littleSVG.webm" type="video/webm">
                    <source src="/media/Spotify/littleSVG.mp4" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
                <div class = "media-caption">[ Little SVG ]</div>
            </div>
            <p>The ‘generatePlot()’ function that establishes the features for the smaller SVG similarly operates on song data and utilizes D3.js to create a visualization, but with a different approach compared to ‘create_bubbles()’. Overall, ‘generatePlot()’ dynamically generates a horizontal plot visualization of songs, allowing users to explore the dataset based on different attributes, with interactive features powered by D3.js.
            </p>
            <p>The initialization of the smaller SVG begins the same as the main SVG: by selecting the SVG element and clearing any existing content within the SVG. Drag behavior functions are defined to enable manipulation of elements within the visualization. Circle elements representing songs are appended to the SVG using data binding. Each circle is filled with a pattern based on the track image and positioned along the x-axis at the center of the SVG. Circles are positioned using a force simulation (alignX()) to create a scatter plot effect. The axis is labeled with ticks that increment by factors of 10 and whose range is defined from the minimum value to the maximum value from the dataset. 
            </p>
            <p>As the initial configuration, the x-axis scale is set up based on the popularity index. The function also establishes event listeners for the decade, energy, and danceability buttons, allowing them to change the x-axis scale and reposition circles based on the numerical values corresponding to each song's release year, popularity score, energy score, and danceability score, respectively. Each button click triggers a transition to update the visualization accordingly. Tooltip functionality is added for mouseover events on circles to display song details.
            </p>
            <div class = "project-section" style = "font-style: italic;">Lyric analysis plot and dynamic tooltip display (lyric_plot_test.js) 
            </div>
            <div style = "width: 40%; margin-right: 2%; margin-bottom: 1%;float: left;">
                <video style = "width: 100%;" muted playsinline>
                    <source src="/media/Spotify/lyricsPage.webm" type="video/webm">
                    <source src="/media/Spotify/lyricsPage.mp4" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
                <div class = "media-caption">[ lyrics plot ]</div>
            </div>
            <p>The CSV file generated by lyricsanalysis.py contained the processed lyrics data, x and y coordinates, cluster assignments, sentences, song titles, artists, cosine similarity scores, and confidence levels. This information was used to visualize the lyric lines in an interactive plot. 
            </p>
            <p>The main scatterplot SVG was created to plot the data, and scales for axes were defined based on the minimum and maximum x and y values of data. Scatterplot circles representing lyric points were drawn using D3, plotted according to their x and y coordinates, and color-coded based on the cluster type the lyric represents. Drag behavior was implemented to make the circles draggable, enhancing interactivity. A force simulation was created to apply forces on the lyric circles for collision detection and positioning, ensuring they don't overlap.
            </p>
            <p>A tooltip was added to display details of each lyric point on the plot upon hovering, showing lyric sentence, cluster, song title, artist, cosine similarity score, and confidence level. The tooltip contains a doughnut chart made using chart.js representing cluster distribution, with each unique cluster color coded via a custom generated color scheme. I also added horizontal meters to depict the x, y, and confidence level values, a circular progress bar for cosine similarity score, and an area chart created through chart.js that graphs all x and y coordinates lyric data points for the chosen song. 
            </p>
            <p>Overall, the code dynamically generates a scatterplot visualization where each circle represents a lyric line from songs. It leverages various D3.js features for data binding, DOM manipulation, tooltip creation, drag behavior, force simulation, zooming, and chart creation, providing an interactive interface for exploring and analyzing the song lyrics data in detail.
            </p>
            <div style = "margin-bottom: 2em;">This project combines intricate backend architecture with frontend interactivity to deliver an engaging music exploration experience. By integrating OAuth2 authentication, Spotify API querying, and data processing through Flask and Python, the backend ensures secure and efficient retrieval and analysis of music data. Concurrently, the frontend interface equips users with interactive controls like dials for playlist selection, meters for visual data representations, and a dynamic record player that dynamically updates song details on hover. Utilizing D3.js, the main SVG visualizes song attributes such as genre, popularity, and energy on a two-dimensional scale, while a smaller SVG offers a compact scatter plot view for detailed exploration. These visualizations, driven by data binding, force simulations, and interactive tooltips, not only enhance user engagement but also provide intuitive insights into playlist dynamics and lyrical themes. The lyric analysis section employs intricate NLP methodologies, including TF-IDF vectorization, K-Means clustering, and PCA dimensionality reduction, to uncover patterns and themes within song lyrics. This analytical depth not only enhances understanding of musical preferences but also offers users a visually engaging way to explore and interpret their playlist dynamics. The project's significance lies in its ability to merge technical sophistication with user-centric visualization, empowering music enthusiasts to discover deeper insights into their favorite tracks and genres.
            </div>
        </div>
    </section>
    <script src = "/js/left-banner.js"></script>
</body>
</html>




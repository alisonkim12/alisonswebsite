<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@100&display=swap" rel="stylesheet">
    <link href="https://fonts.cdnfonts.com/css/basier" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Antonio:wght@100&family=DM+Mono:wght@300&family=Bungee+Hairline&family=Sono:wght@300&family=Telex&family=Commissioner:wght@300&family=Creepster&family=Nabla&family=Foldit&family=Codystar&family=Libre+Barcode+39+Extended+Text&family=Bungee+Hairline&family=Fontdiner+Swanky&family=Mrs+Saint+Delafield&family=UnifrakturMaguntia&family=Sigmar+One&family=Reenie+Beanie&family=Lora&family=Ewert&family=Dr+Sugiyama&family=Gruppo&family=Marhey&family=Mountains+of+Christmas&family=Moirai+One&family=Moo+Lah+Lah&family=Mynerve&family=Rubik+Glitch&family=Rubik+Burned&family=Rubik+Lines&family=Satisfy&family=Barrio&family=Silkscreen&family=Special+Elite&family=Zeyada&display=swap" rel="stylesheet">        
    <!-- <link rel="stylesheet" media="screen and (max-width: 600px)" href="style_mobile.css"> -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/remixicon@4.1.0/fonts/remixicon.css">
    <link rel="icon" href="https://static.vecteezy.com/system/resources/previews/009/266/750/non_2x/sun-icon-design-free-png.png" type="image/png">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/projects.css">
    <script src="https://kit.fontawesome.com/7ed75dc688.js" crossorigin="anonymous"></script>
    <script src="https://worldtimeapi.org/api/timezone/America/Los_Angeles"></script>
    <script src = "/js/right-banner.js"></script>
    <title>alisons⭒computer</title> 
</head>
<style>
     #description-body{
        font-family: "Commissioner", sans-serif;
        font-optical-sizing: auto;
        font-weight: 300;
        font-style: normal;
        width: 90%;
        margin: 0 auto;
        margin-top: 1em;
        font-size: 0.8em;
    }
    
    #description-header{ 
        font-style: italic; 
        font-size: 1em; 
        color: rgba(0,0,0,0.6);
        
    }
    .media-caption{
        font-family: "Sono", monospace;
        font-size: 0.8em;
        margin: 1em auto;
        width: fit-content;
    }
    div p{
        margin-bottom: 1em;
        font-size: 0.9em;
    }

    .project-section{
        font-size: 0.9em;
        margin: 1em 0em;
    }
</style>
<body>
    <section>
        <nav id = "nav-bar" class="banner">
            <div class="left-header">
                <a style = "text-decoration: none;" href = "/index.html" class = "title">
                    <span>alisons.</span>
                    <span id = "computer">computer</span>
                </a>
            </div>
            <div id = "sub-title"></div>
            <div class = "right-header">
                <span id = "line-1">It is <span id = "local-time"></span><i id = "day-or-night" class="fa-solid fa-cloud-sun"></i></span>
                <span id = "line-2"><i class="ri-calendar-event-fill"></i> <span id = "day-of-week"></span><span id = "full-date"></span></span>
                <span id = "line-3"><span id = "temperature"></span> & <span id = "weather"></span><img id = 'weather-icon' class = "icon-here"></img></span>
            </div>
        </nav>
    </section>
    <section id = "section-project-page">
        <div class="page-buttons">
            <span id = "link-home"><a href = "/index.html"><i class="ri-arrow-left-up-line"></i> back to main page</a></span>
            <span id = "link-next-project"><a href = "../angel-of-history/index.html">Angel of History <i class="ri-arrow-right-up-line"></i></a></span>
        </div>
        <div class="project-header">
            <div id="project-title">Trail of Prayers</div>
            <div class = "project-details">
                <span id="project-year">2024</span><span id="project-tools">Flask, UMAP, NumPy, GloVe, scikit-learn</span>
                <div id="project-link">
                    <a href = "" target = "_blank">website <i class="ri-link"></i></a>, 
                    <a href = "https://github.com/alisonkim12/trail-of-prayers" target = "_blank">github repo <i class="ri-link"></i></a>
                </div>
            </div>
        </div>
        <div id="project-description">
            <div id="description-body">
                <div id="description-header">
                    <p>This project is a full-stack web application designed to generate, display, and visualize prayer sentences, integrating both back-end and front-end components to create an interactive user experience. Utilizing the Flask framework, the back end handles the generation of prayer sentences through a combination of natural language processing and machine learning techniques, while the front end employs JavaScript to create dynamic visual elements that enhance user engagement. By leveraging a series of interconnected scripts—each specializing in specific functionalities, such as sentence generation, data processing, and visual representation—the project provides a poetic and artistic exploration and visualization through text analysis.
                    </p>
                </div>
                <div style = "width: 100%; padding-bottom: 0.5em; border-bottom: 0.5px solid black;">Project backend</div>
                <div class = "project-section" style = "font-style: italic;">server.py</div>
                <div style = "width: 25%; margin-right: 2em; float: left;">
                    <img alt = "diagram of the project stack" style = "width: 100%;" src = "/media/prayer/Trail of Prayers stack diagram.png">
                    <div class = "media-caption">[ project stack flow ]</div>
                </div>
                <p>The provided Python script implements a basic web application using the Flask framework, designed to generate and display prayer sentences. It begins by importing necessary modules, including Flask for creating the web application, `multiprocessing` for handling separate processes, and a custom `prayers` module for generating prayer sentences. The Flask application is initialized, and a multiprocessing queue is created to facilitate communication between the main Flask process and the background process responsible for generating sentences.
                </p>
                <p>Two routes are defined: the root route (`/`), which renders the `index.html` template as the main page, and the `/get_text` route, which checks the queue for generated elements. If an element exists, it retrieves it and returns it as a JSON response; if the queue is empty, it responds with `None`. This AJAX-enabled endpoint allows the front end to fetch sentences dynamically without reloading the page.
                </p>
                <p>In the main execution block, a separate process is initiated to run the `generate_sentences` function from the `prayers` module, passing necessary arguments. This enables concurrent execution, allowing sentence generation without blocking the web server. The Flask application is then run in debug mode to facilitate development.
                </p>
                <p>The script efficiently provides a framework for generating prayer sentences asynchronously while serving them to the front-end client through a JSON API. However, improvements can be made in error handling, graceful shutdown of background processes, scalability with more robust message-passing systems, and security measures to safeguard user inputs. Overall, the script establishes a responsive web application that effectively integrates background processing and dynamic content delivery.
                </p>
                <div class = "project-section" style = "font-style: italic;">prayers.py</div>
                <p>The provided Python script processes and analyzes a collection of prayer sentences using various natural language processing techniques and machine learning algorithms. It begins by importing necessary modules and libraries, including NLTK for text processing, NumPy for numerical operations, and data structures from the `datasketch` library for locality-sensitive hashing (LSH). The script reads processed prayer data from a CSV file, extracting prayer lines and associated titles and authors into separate lists.
                </p>
                <p>A custom function, `load_glove_embeddings`, is defined to load pre-trained GloVe word embeddings from a specified file, converting each word into a corresponding vector representation. The script defines a function, `sentence_embedding`, that computes the embedding for an entire sentence by averaging the embeddings of its constituent words, ignoring words not found in the GloVe model. The `preprocess` function tokenizes input sentences, filters out common English stop words as well as specific words related to religious texts (like "thy," "thou," "hast," and "thee"), and returns a cleaned-up version of the sentence.
                </p>
                <p>To find the most similar sentence, the `find_most_similar` function employs the LSH technique. It preprocesses the input sentence, computes its embedding, and uses MinHash to create a probabilistic signature of the sentence. The function then queries the LSH structure for similar sentences, calculating their cosine similarity to the input sentence to identify the most similar one. 
                </p>
                <p>The script randomly selects an initial sentence from the list of prayer sentences, which serves as the starting point for generating a morphing sequence of sentences. It maintains a record of visited sentences to avoid repetition. The `generate_sentences` function iteratively finds the most similar sentence to the current sentence and adds it to the morphing sequence until all sentences have been visited.
                </p>
                <p>Additionally, the script employs UMAP (Uniform Manifold Approximation and Projection) to reduce the dimensionality of the sentence embeddings, facilitating visualization. The `getPrayerCoords` function computes the embeddings for the prayer sentences, applies UMAP to obtain two-dimensional coordinates, and then writes this data, including the original sentences and their corresponding titles and authors, to a JSON file for potential use in visualizations or further analysis.
                </p>
                <p>The script effectively integrates techniques for processing textual data, embedding sentences in a semantic space, and identifying relationships between sentences based on their content. However, it contains commented-out sections for additional features (such as visualizations using matplotlib) and various imports that are not utilized, suggesting potential areas for refinement or expansion. Error handling for file operations, especially regarding the presence of valid embeddings, would also enhance the robustness of the implementation.
                </p>
                <div class = "project-section" style = "font-style: italic;">reading_text.py</div>
                <p>The provided Python script processes multiple text files containing spiritual or mystical writings, filtering and formatting the content for output into a CSV file. It begins by importing necessary libraries, including `nltk` for natural language processing, specifically to tokenize sentences, and `csv` for writing data. The `main` function encapsulates the script’s logic, including a helper function, `filter_strings`, that filters out empty strings or those consisting solely of punctuation. The script reads each text file, splits the content into paragraphs, and creates paired lines from alternating lines within those paragraphs, which are then cleaned of newlines and filtered using `filter_strings`. For each valid line, a dictionary is constructed to store the title of the writing, the author’s name, and the prayer line, which is appended to the `prayerData` list.
                </p>
                <p>The script processes several authors, including Mirabai, Mirra Alfassa, and St. Teresa of Ávila, using a similar structure for each, which could be refactored for better maintainability. After collecting the data, it writes the `prayerData` to a CSV file using `csv.DictWriter`, ensuring a structured output. While the script effectively utilizes NLTK for sentence tokenization and applies string filtering appropriately, it could be improved through error handling for file operations, dynamic configuration for authors and file paths, and better documentation. The presence of unused code and lack of modularity detracts from clarity, suggesting that enhancements in efficiency, logging, and testing for edge cases could further strengthen the script's robustness and usability.
                </p>
                <div style = "width: 100%; padding-bottom: 0.5em; border-bottom: 0.5px solid black;">Project frontend</div>
                <div style = "width: 50%; margin-left: 2em; float: right;">
                    <img alt = "diagram of the project stack" style = "width: 100%;" src = "/media/nature_cam/nature cam stack flow.png">
                    <div class = "media-caption">[ main page ]</div>
                </div>
                <div class = "project-section" style = "font-style: italic;">index.html</div>
                <div class = "project-section" style = "font-style: italic;">prayers.js</div>
                <p>`prayers.js` creates an interactive overlay for displaying sentences and associated visuals (flowers) within a specified area of a webpage. It begins by selecting the necessary DOM elements, including the field and the sentence overlay, and initializes several variables to manage state, including the current sentence index and the positioning direction of the sentences. The `applyZigZagPositioning` function calculates the horizontal and vertical positioning of newly added sentence elements in a zigzag pattern, dynamically adjusting their position based on the current index and a specified direction. The `adjustFontSizeOnScroll` function modifies the font size of each sentence based on its distance from the top of the overlay during scrolling.
                </p>
                <p>The `addSentence` function is responsible for adding new sentences to the overlay, updating the unique words tracked, and applying positioning and visual effects. It also handles mouse hover events that reveal associated flowers for each word in a sentence. The `updateUniqueWords` function processes each sentence to extract words, creating and revealing corresponding flower elements while updating a set of unique words. Each flower element is styled and positioned according to its relation to the sentence it represents. 
                </p>
                <p>The `positionFlower` function determines the placement of flowers relative to the sentence's position, ensuring they are appropriately spaced. The size of flowers and their captions adjusts based on their position within the overlay during scroll events. The code includes event listeners for scrolling and resizing, ensuring that elements remain responsive to changes in the viewport. Additionally, a recurring AJAX call to retrieve new sentences and update the overlay occurs every four seconds, enhancing the dynamic nature of the application. Overall, the script combines various interactive and visual effects to create an engaging user experience.
                </p>
                <div class = "project-section" style = "font-style: italic;">prayercoords.js</div>
                <div style = "width: 30%; margin-right: 2em; float: left;">
                    <img alt = "diagram of the project stack" style = "width: 100%;" src = "/media/nature_cam/nature cam stack flow.png">
                    <div class = "media-caption">[ source index ]</div>
                </div>
                <p>The provided JavaScript code is designed to visualize prayer data as points in a 2D space, employing asynchronous functions for efficient data fetching and manipulation. The `getCoordData()` function retrieves prayer coordinate data from a local JSON file, incorporating error handling to manage potential fetch failures. The `getMinMaxRanges(coordData)` function iterates through the data to determine the minimum and maximum x and y values, which are essential for scaling. The `scaleData(coordData, minX, maxX, minY, maxY)` function rescales the coordinates to fit within the window dimensions, normalizing the data for visual representation. The `createPrayerPoints(scaled_dataset)` function generates HTML elements for each prayer point, applying CSS transforms to position them according to the scaled coordinates, while managing a dictionary (`writerNameLists`) to group elements by writer name. The `connectPoints(scaled_dataset)` function creates visual connections (lines) between prayer points, calculating distances and angles to align the lines properly. The `slidingScale(scaled_dataset)` function introduces an interactive slider to control the visibility of points and lines, enhancing user engagement. The `main()` function orchestrates the entire process, handling data retrieval, scaling, rendering, and setting up event listeners for interactive feedback. Overall, the code combines asynchronous data handling with dynamic DOM manipulation, ensuring a responsive user experience. Potential improvements include enhancing accessibility, optimizing performance for large datasets, modularizing the code for maintainability, and expanding error handling for user feedback. This framework effectively visualizes prayer data, promoting user interaction with the content.
                </p>
                <p>This project showcases the effective integration of back-end and front-end technologies to create a responsive and engaging web application centered around prayer sentences. Through the use of Flask and advanced text processing techniques, the back end dynamically generates content while maintaining efficient communication with the front end. Trail of Prayers represents a comprehensive exploration of computational geometry and visual aesthetics within the web development domain. The significance of this work lies in its ability to seamlessly merge functionality with creativity. By dynamically generating non-overlapping flower placements and creatively arranging child elements with a unique zigzag pattern, the code successfully integrates complex algorithms with intuitive design principles. The project highlights the potential of combining precise calculations with artistic expression, showcasing the ability to transform a simple web page into an interactive and visually engaging experience. 
                </p>
            </div>
        </div>
    </section>
    <script src = "/js/left-banner.js"></script>
</body>
</html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@100&display=swap" rel="stylesheet">
    <link href="https://fonts.cdnfonts.com/css/basier" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Antonio:wght@100&family=DM+Mono:wght@300&family=Bungee+Hairline&family=Sono:wght@300&family=Telex&family=Commissioner:wght@300&family=Creepster&family=Nabla&family=Foldit&family=Codystar&family=Libre+Barcode+39+Extended+Text&family=Bungee+Hairline&family=Fontdiner+Swanky&family=Mrs+Saint+Delafield&family=UnifrakturMaguntia&family=Sigmar+One&family=Reenie+Beanie&family=Lora&family=Ewert&family=Dr+Sugiyama&family=Gruppo&family=Marhey&family=Mountains+of+Christmas&family=Moirai+One&family=Moo+Lah+Lah&family=Mynerve&family=Rubik+Glitch&family=Rubik+Burned&family=Rubik+Lines&family=Satisfy&family=Barrio&family=Silkscreen&family=Special+Elite&family=Zeyada&display=swap" rel="stylesheet">        
    <!-- <link rel="stylesheet" media="screen and (max-width: 600px)" href="style_mobile.css"> -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/remixicon@4.1.0/fonts/remixicon.css">
    <link rel="icon" href="https://static.vecteezy.com/system/resources/previews/009/266/750/non_2x/sun-icon-design-free-png.png" type="image/png">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/projects.css">
    <script src="https://kit.fontawesome.com/7ed75dc688.js" crossorigin="anonymous"></script>
    <script src="https://worldtimeapi.org/api/timezone/America/Los_Angeles"></script>
    <script src = "/js/right-banner.js"></script>
    <title>alisons⭒computer</title> 
</head>
<style>
     #description-body{
        font-family: "Commissioner", sans-serif;
        font-optical-sizing: auto;
        font-weight: 300;
        font-style: normal;
        width: 90%;
        margin: 0 auto;
        margin-top: 1em;
        font-size: 0.8em;
    }
    
    #description-header{ 
        font-style: italic; 
        font-size: 1em; 
        color: rgba(0,0,0,0.6);
        
    }
    .media-caption{
        font-family: "Sono", monospace;
        font-size: 0.8em;
        margin: 1em auto;
        width: fit-content;
    }
    div p{
        margin-bottom: 1em;
        font-size: 0.9em;
    }

    .project-section{
        font-size: 0.9em;
        margin: 1em 0em;
    }
</style>
<body>
    <section>
        <nav id = "nav-bar" class="banner">
            <div class="left-header">
                <a style = "text-decoration: none;" href = "/" class = "title">
                    <span>alisons.</span>
                    <span id = "computer">computer</span>
                </a>
            </div>
            <div id = "sub-title"></div>
            <div class = "right-header">
                <span id = "line-1">It is <span id = "local-time"></span><i id = "day-or-night" class="fa-solid fa-cloud-sun"></i></span>
                <span id = "line-2"><i class="ri-calendar-event-fill"></i> <span id = "day-of-week"></span><span id = "full-date"></span></span>
                <span id = "line-3"><span id = "temperature"></span> & <span id = "weather"></span><img id = 'weather-icon' class = "icon-here"></img></span>
            </div>
        </nav>
    </section>
    <section id = "section-project-page">
        <div class="page-buttons">
            <span id = "link-home"><a href = "/"><i class="ri-arrow-left-up-line"></i> back to main page</a></span>
            <span id = "link-next-project"><a href = "../angel-of-history/index.html">Angel of History <i class="ri-arrow-right-up-line"></i></a></span>
        </div>
        <div class="project-header">
            <div id="project-title">Trail of Prayers</div>
            <div class = "project-details">
                <span id="project-year">2024</span><span id="project-tools">Flask, UMAP, NumPy, GloVe, scikit-learn</span>
                <div id="project-link">
                    <a href = "" target = "_blank">website <i class="ri-link"></i></a>, 
                    <a href = "https://github.com/alisonkim12/trail-of-prayers" target = "_blank">github repo <i class="ri-link"></i></a>
                </div>
            </div>
        </div>
        <div id="project-description">
            <div id="description-body">
                <!-- <p>Coming Soon!</p> -->
                <div id="description-header">
                    <p>Trail of Prayers is an animated interface designed to generate, display, and visualize text, integrating both back-end and front-end components to create an interactive user experience. Utilizing the Flask, the back-end handles the generation of prayer sentences through a combination of natural language processing and machine learning techniques, while the front end employs JavaScript to create dynamic visual elements – a constellation of stars representing each sentence oriented through Uniform Manifold Approximation and Projection (UMAP), and a trail of sentences in continuous sequence, linking each to its most semantically similar line in a 2000+ line corpus from 8 female mystics. By leveraging a series of interconnected scripts—each specializing in specific functionalities, such as sentence generation, data processing, and visual representation— Trail of Prayers illustrates a poetic and artistic exploration and visualization through text analysis.
                    </p>
                </div>
                <div style = "width: 100%; padding-bottom: 0.5em; border-bottom: 0.5px solid black;">Project backend</div>
                <div class = "project-section" style = "font-style: italic;">server.py</div>
                <div style = "width: 25%; margin-right: 2em; float: left;">
                    <img alt = "diagram of the project stack" style = "width: 100%;" src = "/media/prayer/Trail of Prayers stack diagram.png">
                    <div class = "media-caption">[ project stack flow ]</div>
                </div>
                <p>Server.py implements a basic web framework for using Flask, designed to generate and display prayer sentences. It begins by importing necessary modules, including Flask for creating the web application, ‘multiprocessing’ for handling separate processes, and the local python script ‘prayers.py’ that generates each sentence to visualize. The Flask application is initialized, and a multiprocessing queue is created to facilitate communication between the main Flask process and the function call from ‘prayers.py’ responsible for generating sentences.
                </p>
                <p>Two routes are defined: the root route (‘/’), which renders the ‘index.html’ template as the main page, and the ‘/get_text’ route, which routinely checks the queue for generated elements. If an element exists, it retrieves it and returns it as a JSON response; if the queue is empty, it responds with None. This AJAX-enabled endpoint allows the front end JavaScript to fetch sentences dynamically without reloading the page.
                </p>
                <p>A separate process is initiated to run the ‘generate_sentences’ function from the ‘prayers.py’ script, passing necessary arguments. This enables concurrent execution, allowing sentence generation without blocking the web server. The script efficiently provides a framework for generating prayer sentences asynchronously while serving them to the front-end client through a JSON API.
                </p>
                <p>The script efficiently provides a framework for generating prayer sentences asynchronously while serving them to the front-end client through a JSON API. However, improvements can be made in error handling, graceful shutdown of background processes, scalability with more robust message-passing systems, and security measures to safeguard user inputs. Overall, the script establishes a responsive web application that effectively integrates background processing and dynamic content delivery.
                </p>
                <div class = "project-section" style = "font-style: italic;">reading_text.py</div>
                <p>This python script processes the text files containing literature from mystics, filtering and formatting the content for output into a CSV file. It begins by importing necessary libraries, including ‘nltk’ for natural language processing, specifically to tokenize sentences, and ‘csv’ for writing data. The ‘main’ function encapsulates the script’s logic, and includes a helper function, ‘filter_strings’, that filters out empty strings or those consisting solely of punctuation. The script reads each text file, splits the content into paragraphs, and creates paired lines from alternating lines within those paragraphs, which are then cleaned of newlines and filtered using `filter_strings`. For each valid line, a dictionary is constructed to store the title of the writing, the author’s name, and the prayer line, which is appended to the ‘prayerData’ list, a comprehensive dataset of each sentence, its author, and its source. The script processes 8 authors, including Mirabai, Mirra Alfassa, and St. Teresa of Ávila, using a similar structure for each, which are refactored for better maintainability. After collecting all the data, it writes ‘prayerData’ into a CSV file using ‘csv.DictWriter’, ensuring a structured output. 
                </p>
                <div class = "project-section" style = "font-style: italic;">prayers.py</div>
                <div style = "width: 35%; margin-left: 2em; float: right;">
                    <video style = "width: 100%;" muted playsinline>
                        <source src="/media/trail-of-prayers/TrailVideo2X.webm" type="video/webm">
                        <source src="/media/trail-of-prayers/TrailVideo2X.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                    <div class = "media-caption">[ prayer trail ]</div>
                </div>
                <p>Prayers.py is the primary script that constructs the sentence sequence, selecting a random line to begin it. It processes and analyzes a corpus of sentences using various natural language processing techniques and machine learning algorithms. It begins by importing necessary modules and libraries, including NLTK for text processing, NumPy for numerical operations, and data structures from the ‘datasketch’ library for locality-sensitive hashing (LSH). The script reads processed prayer data from a CSV file created by ‘reading_text.py’, extracting prayer lines and associated titles and authors into separate lists.
                </p>
                <p>A custom function, ‘load_glove_embeddings’, is defined to load pre-trained Global Vectors for Word Representation (GloVe) word embeddings from a specified file, ‘glove.6B.300d.text’, converting each word into a corresponding vector representation. The script defines a function, ‘sentence_embedding’, that computes the embedding for an entire sentence by averaging the embeddings of its constituent words, ignoring words not found in the GloVe model. The ‘preprocess’ function tokenizes input sentences, filters out common English stop words as well as specific words related to religious texts (like “thy”, “thou”, “hast”, and “thee”), and returns a cleaned-up version of the sentence. To find the most similar sentence, the `find_most_similar` function employs the LSH technique. It preprocesses the input sentence, computes its embedding, and uses MinHash to create a probabilistic signature of the sentence. The function then queries the LSH structure for similar sentences, calculating their cosine similarity to the input sentence to identify the most similar one. 
                </p>
                <p>The script randomly selects an initial sentence from the list of prayer sentences, which serves as the starting point for generating a morphing sequence of sentences. It maintains a record of visited sentences to avoid repetition. The `generate_sentences` function iteratively finds the most similar sentence to the current sentence and adds it to the morphing sequence until all sentences have been visited.
                </p>
                <p>Additionally, the script employs Uniform Manifold Approximation and Projection (UMAP) to reduce the dimensionality of the sentence embeddings, facilitating visualization. The ‘getPrayerCoords’ function computes the embeddings for the prayer sentences, applies UMAP to obtain two-dimensional coordinates, and then writes this data, including the original sentences and their corresponding titles and authors, to a JSON file for potential use in visualizations or further analysis. The script effectively integrates techniques for processing textual data, embedding sentences in a semantic space, and identifying relationships between sentences based on their content. 
                </p>
                <div style = "width: 100%; padding-bottom: 0.5em; border-bottom: 0.5px solid black;">Project frontend</div>
                <div style = "width: 50%; margin-left: 2em; margin-top: 1em; float: right;">
                    <img alt = "diagram of the project stack" style = "width: 100%; border-radius: 10px;" src = "/media/trail-of-prayers/mainPage.png">
                    <div class = "media-caption">[ main page ]</div>
                </div>
                <div class = "project-section" style = "font-style: italic;">index.html (main page)</div>
                <p>The main page seamlessly integrates two distinct features to form a cohesive landscape. The upper section symbolizes the "sky," where a constellation of connected stars represents each sentence in the corpus. These stars are arranged using a UMAP configuration, with lines connecting the sentences in order. The lower section embodies the "land," where sentences create a flowing trail, surrounded by a field of flowers.
                </p>
                <div class = "project-section" style = "font-style: italic;">prayers.js</div>
                <p>Prayers.js creates an interactive overlay that displays sentences sequentially, forming a trail with associated visuals (flowers) surrounding them like a field at the bottom of a webpage. It begins by selecting the necessary DOM elements, and initializes several variables to manage state, including the current sentence index and the positioning direction of the sentences. To configure the sentences in a zig zag trail pattern, the ‘applyZigZagPositioning’ function calculates the horizontal and vertical positioning of newly added sentence elements in a zigzag pattern, dynamically adjusting their position based on the current index and a specified direction. The ‘adjustFontSizeOnScroll’ function modifies the font size of each sentence based on its distance from the top of the overlay, where sentences further from the bottom appear smaller, enhancing the illusion of depth, during scrolling. The ‘addSentence’ function is responsible for adding new sentences to the overlay, updating the unique words tracked, and applying positioning and visual effects. It also handles mouse hover events that reveal associated flowers for each word in a sentence. The ‘updateUniqueWords’ function processes each sentence to extract words, creating and revealing corresponding flower elements while updating a set of unique words. Each flower element is styled and positioned according to its relation to the position of the sentence it represents. 
                </p>
                <p>The ‘positionFlower’ function determines the placement of flowers relative to the sentence's position, ensuring they are appropriately spaced. The size of flowers and their captions adjusts based on their position within the overlay during scroll events. The code includes event listeners for scrolling and resizing, ensuring that elements remain responsive to changes in the viewport. Additionally, a recurring AJAX call to retrieve new sentences and update the overlay occurs every four seconds.  Overall, the code combines asynchronous data handling with dynamic DOM manipulation, ensuring a responsive user experience. 
                </p>
                <div class = "project-section" style = "font-style: italic;">prayercoords.js</div>
                <div style = "width: 15%; margin-right: 2em; float: left;">
                    <img alt = "diagram of the project stack" style = "width: 100%;" src = "/media/trail-of-prayers/bibliography.png">
                    <div class = "media-caption">[ source index ]</div>
                </div>
                <p>The provided JavaScript code is designed to visualize prayer data as points in a 2D space, employing asynchronous functions for efficient data fetching and manipulation. The ‘getCoordData’ function retrieves prayer coordinate data from a local JSON file, incorporating error handling to manage potential fetch failures. The ‘getMinMaxRanges()’ function iterates through the data to determine the minimum and maximum x and y values, which are used to scale the position of the coordinates. The ‘scaleData’ function rescales the coordinates to fit within the window dimensions, normalizing the data for visual representation. The ‘createPrayerPoints’ function generates ‘article’ HTML elements for each prayer point, applying CSS transforms to position them according to the scaled coordinates, while managing a dictionary (‘writerNameLists’) to group elements by writer name. The ‘connectPoints’ function creates lines between prayer points, calculating distances and angles to align the lines properly. The ‘slidingScale’ function introduces an interactive slider that sequentially highlights each sentence in the UMAP according to the dataset's original order.
                </p>
                <p>Trail of Prayers represents a comprehensive exploration of computational geometry and visual aesthetics with an effective integration of natural language processing analysis. The significance of this work lies in its ability to seamlessly merge functionality with creativity. Through the use of Flask and advanced text processing techniques, the back-end dynamically generates content for visualization on the front end. The front-end enhances user interaction, enabling a visually rich experience that displays textual data in an insightful and interactive way. The attention to detail in ensuring non-overlapping elements, smooth animations, and a fluid user interface underlines the robustness of the code and its adaptability to various use cases. The project highlights the potential of combining precise calculations with artistic expression, showcasing the ability to transform a simple web page into an interactive and visually engaging experience. 
                </p>
            </div>
        </div>
    </section>
    <script src = "/js/left-banner.js"></script>
</body>
</html>